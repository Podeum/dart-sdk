import 'package:tinode/src/models/topic-subscription.dart';
import 'package:tinode/src/models/delete-transaction.dart';
import 'package:tinode/src/models/topic-description.dart';
import 'package:tinode/src/models/credential.dart';

class ServerMessage {
  final CtrlMessage ctrl;
  final MetaMessage meta;
  final DataMessage data;

  ServerMessage({this.ctrl, this.meta, this.data});

  static ServerMessage fromMessage(Map<String, dynamic> msg) {
    return ServerMessage(
      ctrl: msg['ctrl'] != null ? CtrlMessage.fromMessage(msg['ctrl']) : null,
      meta: msg['meta'] != null ? MetaMessage.fromMessage(msg['meta']) : null,
      data: msg['data'] != null ? DataMessage.fromMessage(msg['data']) : null,
    );
  }
}

class CtrlMessage {
  /// Message Id
  final String id;

  /// Related topic
  final String topic;

  /// Message code
  final int code;

  /// Message text
  final String text;

  /// Message timestamp
  final DateTime ts;

  final dynamic params;

  CtrlMessage({
    this.id,
    this.topic,
    this.code,
    this.text,
    this.ts,
    this.params,
  });

  static CtrlMessage fromMessage(Map<String, dynamic> msg) {
    return CtrlMessage(
      id: msg['id'],
      code: msg['code'],
      text: msg['text'],
      topic: msg['topic'],
      params: msg['params'],
      ts: msg['ts'] != null ? DateTime.parse(msg['ts']) : DateTime.now(),
    );
  }
}

class MetaMessage {
  /// Message Id
  final String id;

  /// Related topic
  final String topic;

  /// Message timestamp
  final DateTime ts;

  /// Topic description, optional
  final TopicDescription desc;

  ///  topic subscribers or user's subscriptions, optional
  final List<TopicSubscription> sub;

  /// Array of tags that the topic or user (in case of "me" topic) is indexed by
  final List<String> tags;

  /// Array of user's credentials
  final List<UserCredential> cred;

  /// Latest applicable 'delete' transaction
  final DeleteTransaction del;

  MetaMessage({this.id, this.topic, this.ts, this.desc, this.sub, this.tags, this.cred, this.del});

  static MetaMessage fromMessage(Map<String, dynamic> msg) {
    return MetaMessage(
      id: msg['id'],
      topic: msg['topic'],
      ts: msg['ts'] != null ? DateTime.parse(msg['ts']) : DateTime.now(),
      desc: TopicDescription.fromMessage(msg['desc']),
      sub: msg['sub'] != null && msg['sub'].length != null ? msg['sub'].map((Map<String, dynamic> sub) => TopicSubscription.fromMessage(sub)) : [],
      tags: msg['tags'],
      cred: msg['cred'] != null && msg['cred'].length != null ? msg['cred'].map((Map<String, dynamic> cred) => UserCredential.fromMessage(cred)) : [],
      del: DeleteTransaction.fromMessage(msg['del']),
    );
  }
}

class DataMessage {
  /// topic which distributed this message
  final String topic;

  /// id of the user who published the message; could be missing if the message was generated by the server
  final String from;

  /// set of string key-value pairs, passed unchanged from {pub}, optional
  final Map<String, dynamic> head;

  /// Timestamp
  final DateTime ts;

  /// Server-issued sequential Id
  final int seq;

  /// object, application-defined content exactly as published by the user in the {pub} message
  final dynamic content;

  DataMessage({this.topic, this.from, this.head, this.ts, this.seq, this.content});

  static DataMessage fromMessage(Map<String, dynamic> msg) {
    return DataMessage(
      topic: msg['topic'],
      from: msg['from'],
      head: msg['head'],
      ts: msg['ts'] != null ? DateTime.parse(msg['ts']) : null,
      seq: msg['seq'],
      content: msg['content'],
    );
  }
}
